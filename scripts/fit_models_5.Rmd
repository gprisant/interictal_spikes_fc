---
title: "Do Interictal Discharges Affect iEEG Functional Connectivity"
output: html_document
author: Jennifer Stiso
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# clean workspace
rm(list=ls())

if (!require("pacman")) install.packages("pacman")
pacman::p_load(ggplot2, dplyr, lm.beta, RColorBrewer, nationalparkcolors, rjson, reticulate, gridExtra, wesanderson, MASS, outliers, lmerTest, stringr)

# set up python for later
use_python("/Users/stiso/anaconda3/bin/python") # path to python binary
py_config() # check it is using the specified version

# directory for RAM data, request from XXX
RAM_dir = '/Volumes/bassett-data/Jeni/RAM/'

# parameters
win = 3

```

## Functions
```{r}
get_beta <- function(d, ys, f) {
  # scale x's
  d['spike_num'] <- scale(d['spike_num'])
  d['power'] <- scale(d['power'])
  
  # fit models for every given predictor
  for (y in ys){
    # remove nan rows
    d_lm = d[!is.na(d[y]),]
    
    # check if multiple sess and exper
    if (length(unique(d_lm$sess_exper)) > 1) {
      f_full <- paste(f, 'sess_exper', sep = ' + ')
      # to prevent prevent factor level errors
      d_lm$sess_exper = as.factor(d_lm$sess_exper)
    } else {
      f_full <- f
    }
    
    beta_bin_name <- paste(y, 'beta_bin', sep = '_')
    beta_num_name <- paste(y, 'beta_num', sep = '_')
    if (dim(d_lm[y])[1] == 0){ # check for nans
      d[beta_bin_name] <- NaN
      d[beta_num_name] <- NaN
    } else {
      # scale y
      d_lm[y] <- scale(d_lm[y])
      
      # make spike a factor - prevent factor level errors
      d_lm$bin_spike <- as.factor(d_lm$bin_spike)
      # for debugging
      #print(paste(y, d_lm$band[1], d_lm$fc_measure[1], d_lm$region[1]))
      
      # fit
      # check for singular matrix (only two values for spike_num)
      if (length(unique(d_lm$spike_num)) > 2){
        try({fit <- rlm(as.formula(paste(y, f_full, sep='')), data=d_lm, maxit=500)
        d[beta_bin_name] <- fit$coefficients['bin_spikeTRUE']
        d[beta_num_name] <- fit$coefficients['spike_num']})
      } else {
        f_full <- str_remove(f_full, fixed("+ bin_spike"))
        try({fit <- rlm(as.formula(paste(y, f_full, sep='')), data=d_lm, maxit=500)
        d[beta_bin_name] <- fit$coefficients['bin_spikeTRUE']
        d[beta_num_name] <- NaN})
      }

    }
  }
  return(d)
}
```

# Methods

words

## Load Data

```{r}
# get subjects from all releases
releases <- c('1', '2', '3')
subj <- list()
for (r in releases){
  curr_info <- paste(RAM_dir, 'release', r, '/protocols/r1.json', sep='')
  df <- rjson::fromJSON(file = curr_info)
  df <- names(df$protocols$r1$subjects) %>%
    lapply(function(x){paste('release', r, '/r1/', x, sep ='')})
  subj <- append(subj, df)
}

```

## Fit Models

```{r}
# Do we want to make plots? faster if no
save_plot = FALSE

# intiialize, make constants
# constant fields
const_vars <- c('subj', 'hand', 'age', 'gender', 'race')
form <- ' ~ power + bin_spike + spike_num'
ys = c('str', 'str_soz', 'str_not_soz', 'str_spike', 'str_not_spike')

# final df
col_names <- c("fc_measure", "band", 'band_measure', "str_beta_bin", "str_beta_num", "subj", "hand", "age", "gender", "race", 'n_tp')
net_betas <- data.frame(matrix(ncol = length(col_names), nrow = 0))
colnames(net_betas) = col_names
col_names = c("subj", "fc_measure", "band", 'band_measure', "str_soz_beta_bin", "str_not_soz_beta_bin", "str_spike_beta_bin", 
              "str_not_spike_beta_bin","str_soz_beta_num", "str_not_soz_beta_num", "str_spike_beta_num", 'x', 'y', 'z', 
              "str_not_spike_beta_num", "elec", "region", "n_tp", "elec_in_soz", "elec_spike", "age", "gender", "race", "hand" )
node_betas <- data.frame(matrix(ncol = length(col_names), nrow = 0))
colnames(node_betas) = col_names

# for each subject, load their data and fit some models
for (s in subj){
  # load strengths from matlab
  curr_csv <- paste(RAM_dir, 'FC/', s, '/win_', as.character(win), '/fc_data.csv', sep = '')
  if (file.exists(curr_csv) ){
    node_data <- read.csv(curr_csv, header = TRUE, sep = ",", stringsAsFactors = FALSE,
                          colClasses=c(gender='character', hand='character', race='numeric', age='numeric', spike_num='numeric'))
  }
  if (dim(node_data)[1] > 0){
    print(paste('Subj', s)) 
    # add band measure, combined string, for easy indexing (keep separate for plotting)
    node_data <- mutate(node_data, band_measure = paste(band, fc_measure, sep = '_'))
    # add sess_exper for model, dont actually want to model them separately
    node_data <- mutate(node_data, sess_exper = paste(sess, exper, sep = '_'))
    # add binary spike
    node_data$bin_spike = node_data$spike_num > 0
    # there shouldn't be any negative numbers, but if there are skip
    if (any(node_data$spike_num[complete.cases(node_data$spike_num)] < 0)){
      node_data$spike_num[node_data$spike_num < 0] = NaN
      warning("This dataset had negative spike numbers: check the spreadsheet")
      next
    }
    # there shouldn't be any NaNs, but if there are skip
    if (any(is.nan(node_data$spike_num))){
      warning("This dataset had NaN spike numbers: check the spreadsheet")
      next
    }
    # log transform
    node_data$spike_num[node_data$spike_num != 0] = log10(node_data$spike_num[node_data$spike_num != 0])
    # drop hg phase locking - PLV not interpretable for wide band signals
    node_data <- filter(node_data, band_measure != "hg_plv")
    # remove duplicate time points, if present
    node_data <- node_data %>% distinct()
    
    # get network level strength separated by soz and not soz
    net_data <- group_by(node_data, sess_exper, time, spike_num, bin_spike, fc_measure, band, band_measure) %>%
      dplyr::summarise(str = mean(str, na.rm=TRUE), str_spike = mean(str_spike, na.rm=TRUE), 
                       str_not_spike = mean(str_not_spike, na.rm=TRUE), power = mean(power))
    # for soz networks, you can't average over all elecs, have to break them up
    tmp_soz = group_by(node_data, elec_in_soz, sess_exper, time, spike_num, bin_spike, fc_measure, band, band_measure) %>%
      dplyr::summarise(str_soz = mean(str_soz, na.rm=TRUE), str_not_soz = mean(str_not_soz, na.rm=TRUE))
    # remove not soz elecs from str_soz, and visa versa
    tmp_soz$str_soz[tmp_soz$elec_in_soz == 0] <- NA
    tmp_soz$str_not_soz[tmp_soz$elec_in_soz == 1] <- NA
    # now colapse over elec_in_soz
    tmp_soz <- group_by(node_data, sess_exper, time, spike_num, bin_spike, fc_measure, band, band_measure) %>%
      dplyr::summarise(str_soz = mean(str_soz, na.rm=TRUE), str_not_soz = mean(str_not_soz, na.rm=TRUE))
    # now merge on shared features (subj, band, time, etc)
    net_data = merge(net_data, tmp_soz, by = c('sess_exper', 'time', 'spike_num', 'bin_spike', "fc_measure", 'band', 'band_measure'))
    
    # add constants
    net_data[const_vars] = node_data[const_vars][1,]
    
    # plots
    if (save_plot){
        p1 <- ggplot(data=net_data[net_data$spike_num != 0,], aes(x=spike_num)) + geom_histogram() + theme_minimal()
        p2 <- ggplot(data=net_data[net_data$spike_num != 0,], aes(x=str, color=band, fill=as.factor(fc_measure))) + 
          geom_histogram(alpha=0.7) + theme_minimal() + scale_fill_manual(values=park_palette("Saguaro")) + scale_color_grey()
        p <- grid.arrange(p1, p2, nrow=2)
        ggsave(paste(RAM_dir, 'img/models/', net_data$subj, '_net_hist.png', sep=''), plot=p, device = 'png')
    }
  
    # for every fc_meansure and band, fit network model
    try({
      curr_net_beta <- group_by(net_data, band_measure) %>%
        group_modify(~ get_beta(.x,ys, form)) %>%
        dplyr::summarise(n_tp = length(time), str_beta_bin = str_beta_bin[1], str_beta_num = str_beta_num[1], 
                         str_soz_beta_bin = str_soz_beta_bin[1],  str_soz_beta_num = str_soz_beta_num[1],
                         str_not_soz_beta_num = str_not_soz_beta_num[1], str_spike_beta_num = str_spike_beta_num[1],
                         str_not_soz_beta_bin = str_not_soz_beta_bin[1], str_spike_beta_bin = str_spike_beta_bin[1],
                         str_not_spike_beta_bin = str_not_spike_beta_bin[1],fc_measure = fc_measure[1],
                         str_not_spike_beta_num = str_not_spike_beta_num[1], band = band[1])
      curr_net_beta[const_vars] <- node_data[const_vars][1,]
      
      # concatenate
      net_betas <- suppressWarnings(bind_rows(curr_net_beta, net_betas)) # silence warnings about converting factors to strings
    })

    # fit node models
    try({
        curr_node_beta <- group_by(node_data, elec, band_measure) %>%
            group_modify(~ get_beta(.x,ys, form)) %>%
            dplyr::summarise(n_tp = length(time), elec_spike = mean(elec_has_spike), elec_in_soz = elec_in_soz[1], str_soz_beta_bin = str_soz_beta_bin[1], 
                             str_not_soz_beta_bin = str_not_soz_beta_bin[1], str_spike_beta_bin = str_spike_beta_bin[1], 
                             str_not_spike_beta_bin = str_not_spike_beta_bin[1], str_beta_bin = str_beta_bin[1], str_soz_beta_num = str_soz_beta_num[1], 
                             str_not_soz_beta_num = str_not_soz_beta_num[1], str_spike_beta_num = str_spike_beta_num[1], str_beta_num = str_beta_num[1],
                             str_not_spike_beta_num = str_not_spike_beta_num[1], fc_measure = fc_measure[1], band = band[1], region = region[1], x = x[1],
                             y = y[1], z = z[1])
          curr_node_beta[const_vars] <- net_data[const_vars][1,]
          
        #  concetenate
        node_betas <- suppressWarnings(bind_rows(curr_node_beta, node_betas)) # silence warnings about converting factors to strings
      })
  }
}

# save betas
write.csv(net_betas, file = paste(RAM_dir, 'group_analysis/win_', as.character(win), '/network_stats.csv', sep=''))
write.csv(node_betas, file = paste(RAM_dir, 'group_analysis/win_', as.character(win), '/node_stats.csv', sep=''))

```

```{r}
# for debugging
tmp = dplyr::filter(node_data, region == "parahippocampal", band_measure == "theta_plv")
d1 = dplyr::filter(tmp, elec=="LITG1")
y = "str_not_spike"
f = form
d = d1
```

Tests on betas

```{r}
net_data = read.csv('/Volumes/bassett-data/Jeni/RAM/group_analysis/win_', as.character(win), 'net_data_clean.csv')
net_data$race = as.factor(net_data$race)
soz_data = read.csv('/Volumes/bassett-data/Jeni/RAM/group_analysis/win_', as.character(win), 'net_soz_data_clean.csv')
soz_data$race = as.factor(soz_data$race)
soz_data <- mutate(soz_data, band_measure = paste(band, fc_measure, sep = '_'))
spike_data = read.csv('/Volumes/bassett-data/Jeni/RAM/group_analysis/win_', as.character(win), 'net_spike_data_clean.csv')
spike_data$race = as.factor(spike_data$race)
spike_data <- mutate(spike_data, band_measure = paste(band, fc_measure, sep = '_'))

# binary
# number of spikes
fc = unique(net_data$band)
for (m in fc){
  print(m)
    fit = lmer(soz_beta_bin ~  SOZ*fc_measure + race + gender + hand + age + (1|subj), data=dplyr::filter(soz_data, band == m))
    print(anova(fit))
}

length(unique(net_betas$subj))
```

```{r}
# number of spikes
fc = unique(net_data$band)
for (m in fc){
  print(m)
    fit = lmer(soz_beta_num ~  SOZ*fc_measure + race + gender + hand + age + (1|subj), data=dplyr::filter(soz_data, band == m))
    print(anova(fit))
}
```
```{r}
# binary, for spikes
fc = unique(net_data$band)
for (m in fc){
  print(m)
    fit = lmer(spike_beta_bin ~  spike*fc_measure + race + gender + hand + age + (1|subj), data=dplyr::filter(spike_data, band == m))
    print(anova(fit))
}

```
```{r}
# for spikes
# number of spikes
fc = unique(net_data$band)
for (m in fc){
  print(m)
    fit = lmer(spike_beta_num ~  spike*fc_measure + race + gender + hand + age + (1|subj), data=dplyr::filter(spike_data, band == m))
    print(anova(fit))
}

```


```{r}
bfc = unique(net_data$band_measure)
bin_ps = list()
bin_ts = list()
bin_df = list()
for (m in bfc){
  print(m)
  curr <- filter(net_data, band_measure == m)
  stat <- t.test(curr$str_beta_bin)
  print(stat)
  bin_ps = c(bin_ps, stat$p.value)
  bin_ts = c(bin_ts, stat$statistic)
  bin_df = c(bin_df, stat$parameter)
}

bin_stats = data.frame(p = p.adjust(bin_ps, method="bonferroni"), t = unlist(bin_ts), df = unlist(bin_df), measure = bfc, sig = p.adjust(bin_ps, method="bonferroni") < 0.05)
bin_stats

```

```{r}
num_ps = list()
num_ts = list()
num_df = list()
for (m in bfc){
  print(m)
  curr <- filter(net_data, band_measure == m)
  stat <- t.test(curr$str_beta_num)
  print(stat)
  num_ps = c(num_ps, stat$p.value)
  num_ts = c(num_ts, stat$statistic)
  num_df = c(num_df, stat$parameter)
}

num_stats = data.frame(p = p.adjust(num_ps, method="bonferroni"), t = unlist(num_ts), df = unlist(num_df), measure = bfc, sig = p.adjust(num_ps, method="bonferroni") < 0.05)
num_stats

```

 # Relationship with behavior
 
```{r}
net_task_data = read.csv('/Volumes/bassett-data/Jeni/RAM/group_analysis/win_', as.character(win), 'net_task_data_clean.csv')
net_task_data$race = as.factor(net_task_data$race)
net_task_data <- mutate(net_task_data, band_measure = paste(band, fc_measure, sep = '_'))

# binary
# number of spikes
fc = unique(net_task_data$fc_measure)
for (m in fc){
  print(m)
  if (m != 'ar' && m != 'xcorr'){
    fit = lm(nav ~  str_beta_num*band + race + gender + hand + age, data=dplyr::filter(net_task_data, fc_measure == m))
    print(anova(fit))
  } else {
    fit = lm(nav ~  str_beta_num + race + gender + hand + age, data=dplyr::filter(net_task_data, fc_measure == m))
    print(anova(fit))
  }
}
```

```{r}
fit = lm(nav ~  str_beta_num*band + race + gender + hand + age, data=dplyr::filter(net_task_data, fc_measure == 'aec'))
summary(fit)
```

## EDA

```{python}
# imports
import numpy as np
import pandas as pd
import seaborn as sns

# directories
RAM_dir = '/Volumes/bassett-data/Jeni/RAM/'

# load data
net_data = pd.read_csv(RAM_dir + 'group_analysis/network_stats.csv')
node_data = pd.read_csv(RAM_dir + 'group_analysis/node_stats.csv')

node_data.head()
```
